!-----------------------------------------------------------------------------
! (C) Crown copyright 2022 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!> @brief Integrate total energy evaluated at W3 locations
module calc_total_energy_alg_mod

  use compute_column_integral_kernel_mod,                                      &
                                     only: compute_column_integral_kernel_type
  use constants_mod,                 only: r_def, i_def, pi
  use driver_water_constants_mod,    only: Lc => latent_heat_h2o_condensation, &
                                           Lf => latent_heat_h2o_fusion
  use field_mod,                     only: field_type
  use field_collection_mod,          only: field_collection_type
  use fs_continuity_mod,             only: W3, Wtheta
  use function_space_collection_mod, only: function_space_collection
  use geometric_constants_mod,       only: get_height
  use log_mod,                       only: log_event,         &
                                           log_scratch_space, &
                                           LOG_LEVEL_DEBUG
  use physics_mappings_alg_mod,      only: map_physics_scalars
  use physical_op_constants_mod,     only: get_geopotential
  use mesh_mod,                      only: mesh_type
  use mr_indices_mod,                only: nummr, imr_cl, imr_ci, imr_r, imr_s
  use physical_op_constants_mod,     only: get_da_msl_proj
  use planet_config_mod,             only: cv, radius

  implicit none

  private
  public :: calc_total_energy_alg

contains

  !> @details Calculate total energy of the atmosphere accounting for the following:
  !>            internal

  subroutine calc_total_energy_alg( derived_fields, exner, rho, mr, &
                                    mesh, twod_mesh, total_energy )

    implicit none

    type( field_collection_type ), intent(in) :: derived_fields
    type( field_type ), intent(in)            :: exner
    type( field_type ), intent(in)            :: rho
    type( field_type ), intent(in)            :: mr(nummr)

    type (mesh_type ), intent(in), pointer    :: mesh
    type( mesh_type ), intent(in), pointer    :: twod_mesh

    real( kind=r_def ), intent(out)           :: total_energy

    ! Set pointers
    type( field_type ), pointer :: theta_in_w3  => null()
    type( field_type ), pointer :: u_in_w3      => null()
    type( field_type ), pointer :: v_in_w3      => null()
    type( field_type ), pointer :: w_in_w3      => null()
    type( field_type ), pointer :: phi          => null()
    type( field_type ), pointer :: dA           => null()
    type( field_type ), pointer :: height_w3    => null()
    type( field_type ), pointer :: height_wth   => null()

    type( field_type ) :: energy_term, energy_field
    type( field_type ) :: tot_col_energy
    type( field_type ) :: mr_sum, mr_w3

    real( kind=r_def ) :: Lcf
    real( kind=r_def ) :: area

    area = 4.0_r_def * pi * radius ** 2_i_def

    Lcf = Lc + Lf

    call derived_fields%get_field('theta_in_w3', theta_in_w3)
    call derived_fields%get_field('u_in_w3', u_in_w3)
    call derived_fields%get_field('v_in_w3', v_in_w3)
    call derived_fields%get_field('w_in_w3', w_in_w3)
    phi         => get_geopotential(mesh%get_id())
    dA          => get_da_msl_proj( twod_mesh%get_id() )
    height_w3   => get_height( W3, mesh%get_id() )
    height_wth  => get_height( Wtheta, mesh%get_id() )

    call energy_field%initialise( vector_space =                                  &
                                  function_space_collection%get_fs(mesh, 0, W3) )

    call energy_term%initialise( vector_space =                                  &
                                 function_space_collection%get_fs(mesh, 0, W3) )

    call mr_sum%initialise( vector_space =                                      &
                            function_space_collection%get_fs(mesh, 0, Wtheta) )

    call mr_w3%initialise( vector_space =                                  &
                           function_space_collection%get_fs(mesh, 0, W3) )

    call tot_col_energy%initialise( vector_space =                                       &
                                    function_space_collection%get_fs(twod_mesh, 0, W3) )

    call invoke( setval_c(energy_field, 0.0_r_def),                   &
                 setval_X(energy_term, u_in_w3),                      &
                 inc_X_powint_n(energy_term, 2_i_def),                &
                 inc_X_plus_bY(energy_field, 0.5_r_def, energy_term), &
                 setval_X(energy_term, v_in_w3),                      &
                 inc_X_powint_n(energy_term, 2_i_def),                &
                 inc_X_plus_bY(energy_field, 0.5_r_def, energy_term), &
                 setval_X(energy_term, w_in_w3),                      &
                 inc_X_powint_n(energy_term, 2_i_def),                &
                 inc_X_plus_bY(energy_field, 0.5_r_def, energy_term), & ! kinetic
                 inc_X_plus_Y(energy_field, phi),                     & ! geopotential
                 X_times_Y(energy_term, theta_in_w3, exner),          &
                 inc_X_plus_bY(energy_field, cv, energy_term),        & ! dry internal
                 setval_X(mr_sum, mr(imr_cl)),                        &
                 inc_X_plus_Y(mr_sum, mr(imr_r)) )                      ! liquid m.r.

    call map_physics_scalars(mr_w3, mr_sum)

    call invoke( inc_X_minus_bY(energy_field, Lc, mr_w3), & ! liquid water energy
                 setval_X(mr_sum, mr(imr_ci)),            &
                 inc_X_plus_Y(mr_sum, mr(imr_s)) )          ! ice mixing ratio`

    call map_physics_scalars(mr_w3, mr_sum)

    total_energy = 0.0_r_def

    ! Ice water energy, density factor, global integral
    call invoke( inc_X_minus_bY(energy_field, Lcf, mr_w3),                       &
                 inc_X_times_Y(energy_field, rho),                               &
                 compute_column_integral_kernel_type(energy_field, height_w3,    &
                                                     height_wth, tot_col_energy, &
                                                     radius),                    &
                 inc_X_times_Y(tot_col_energy, dA),                              &
                 sum_X(total_energy, tot_col_energy) )

    write(log_scratch_space, '(''calc_total_energy: '', e30.22)') total_energy
    call log_event(log_scratch_space, LOG_LEVEL_DEBUG)

  end subroutine calc_total_energy_alg

end module calc_total_energy_alg_mod
