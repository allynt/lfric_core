!-----------------------------------------------------------------------------
! (C) Crown copyright 2022 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
module model_clock_mod_shadow_test

  use clock_mod,       only : clock_type
  use constants_mod,   only : i_timestep, r_second
  use model_clock_mod, only : model_clock_type
  use pFUnit_mod,      only : anyExceptions,  &
                              assertEqual,    &
                              assertTrue,     &
                              SourceLocation, &
                              TestCase

  implicit none

  private
  public test_shadow_clock

  @TestCase
  type, public, extends(TestCase) :: shadow_clock_test_type
    private
  contains
    procedure test_shadow_clock
  end type shadow_clock_test_type


  type, extends(clock_type) :: clock_stub_type
    private
    integer(i_timestep), public :: first_step
    integer(i_timestep), public :: current_step
    integer(i_timestep), public :: last_step
    real(r_second),      public :: seconds_per_step
  contains
    private
    procedure, public :: get_first_step
    procedure, public :: get_step
    procedure, public :: get_last_step
    procedure, public :: tick
    procedure, public :: is_initialisation
    procedure, public :: get_seconds_per_step
    procedure, public :: seconds_from_steps
  end type clock_stub_type


contains


  @test
  subroutine test_shadow_clock( this )

    implicit none

    class(shadow_clock_test_type), intent(inout) :: this

    type(clock_stub_type)  :: shadow_clock
    type(model_clock_type) :: test_unit
    logical                :: running

    shadow_clock%first_step = 2
    shadow_clock%current_step = 3
    shadow_clock%last_step = 9
    shadow_clock%seconds_per_step = 1.23_r_second

    test_unit = model_clock_type(4, 7, 1.9_r_second, 8.3_r_second)
    call test_unit%add_clock(shadow_clock)

    @assertEqual( 2, shadow_clock%get_first_step() )
    @assertEqual( 3, shadow_clock%get_step() )
    @assertEqual( 9, shadow_clock%get_last_step() )
    @assertEqual( 1.23_r_second, shadow_clock%get_seconds_per_step(), 0.001_r_second )

    @assertEqual( 4, test_unit%get_first_step() )
    @assertEqual( 4, test_unit%get_step() )
    @assertEqual( 7, test_unit%get_last_step() )
    @assertEqual( 1.9_r_second, test_unit%get_seconds_per_step() )
    @assertTrue( test_unit%is_spinning_up() )

    running = test_unit%tick()

    @assertTrue( running )
    @assertEqual( 4, test_unit%get_step() )
    @assertEqual( 4, shadow_clock%get_step() )

    running = test_unit%tick()

    @assertTrue( running )
    @assertEqual( 5, test_unit%get_step() )
    @assertEqual( 5, shadow_clock%get_step() )

  end subroutine test_shadow_clock


  function get_first_step( this )
    implicit none
    class(clock_stub_type), intent(in) :: this
    integer(i_timestep) :: get_first_step
    get_first_step = this%first_step
  end function get_first_step

  function get_step( this )
    implicit none
    class(clock_stub_type), intent(in) :: this
    integer(i_timestep) :: get_step
    get_step = this%current_step
  end function get_step

  function get_last_step( this )
    implicit none
    class(clock_stub_type), intent(in) :: this
    integer(i_timestep) :: get_last_step
    get_last_step = this%last_step
  end function get_last_step

  function tick( this )
    implicit none
    class(clock_stub_type), intent(inout) :: this
    logical :: tick
    this%current_step = this%current_step + 1_i_timestep
    tick = .false.
  end function tick

  function is_initialisation( this )
    implicit none
    class(clock_stub_type), intent(in) :: this
    logical :: is_initialisation
    is_initialisation = .false.
  end function is_initialisation

  function get_seconds_per_step( this )
    implicit none
    class(clock_stub_type), intent(in) :: this
    real(r_second) :: get_seconds_per_step
    get_seconds_per_step = this%seconds_per_step
  end function get_seconds_per_step

  function seconds_from_steps( this, period )
    implicit none
    class(clock_stub_type), intent(in) :: this
    integer(i_timestep),    intent(in) :: period
    real(r_second) :: seconds_from_steps
    seconds_from_steps = 0.0_r_second
  end function seconds_from_steps


end module model_clock_mod_shadow_test
